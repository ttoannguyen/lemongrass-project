Website được phát triển với mục đích giúp cửa hàng kinh doanh vật phẩm trang
trí lễ hội và khách hàng có thể thực hiện việc mua bán thông qua mạng Internet. Giao
diện website được thiết kế gồm 2 phần: phần giao diện của quản lý và giao diện khách
hàng. Hệ thống gồm 3 nhóm người dùng: người dùng quản lý, khách hàng (đã có tài
khoản), khách vãng lai (chưa có tài khoản). Giao diện quản lý dành riêng cho người
quản lý, giao diện khách hàng được sử dụng cho khách hàng và khách vãng lai. Khách
vãng lai sau khi đăng nhập sẽ trở thành khách hàng, khách hàng có thể thực hiện các
chức năng của khách vãng lai.
Khách vãng lai là người dùng chưa có tài khoản trong hệ thống, khách vãng lai có
thể đăng ký tài khoản thông qua chức năng đăng ký bằng cách điền email, mật khẩu.
Khách vãng lai có thể thực hiện chức năng: đăng ký tài khoản, xem chi tiết sản phẩm,
tìm kiếm sản phẩm, lọc sản phẩm, xem bài viết, hỏi đáp với hộp thoại tự động, điều
khiển bằng giọng nói. Chức năng xem chi tiết sản phẩm cho phép người dùng xem
chi tiết tất cả các sản phẩm; chức năng tìm kiếm cho phép người dùng tìm kiếm sản
phẩm theo tên; chức năng lọc sản phẩm cho phép người dùng lọc theo lễ hội, lọc theo
giá; chức năng đăng ký cho phép đăng ký tài khoản vào hệ thống. Chức năng xem bài
viết cho phép khách vãng lai có thể xem các bài viết trên hệ thống. Chức năng hỏi
đáp với hộp thoại tự động cho phép người dùng có thể tìm hiểu về website hay các
thông tin liên quan đến các vật phẩm trang trí lễ hội có trong website một cách nhanh
chóng. Người dùng tương tác bằng cách nhập các câu hỏi thông qua hộp trò chuyện,
hệ thống trả lời tự động sẽ cung cấp các câu trả lời tương ứng với câu hỏi được đặt
ra. Chức năng điều khiển bằng giọng nói với trợ lý ảo mua sắm, giúp khách vãng lai
có thể thực hiện các chức năng cơ bản bằng giọng nói mà không phải thực hiện mua
sắm thủ công như thao tác bấm chuột, bàn phím, ..., giúp tăng trải nghiệm của khách
hàng khi mua sắm. Khi sử dụng chức năng điều khiển bằng giọng nói, yêu cầu người
dùng có thể đọc hướng dẫn trước khi sử dụng để có trải nghiệm tốt nhất.
Khách hàng là người dùng đã đăng nhập vào hệ thống thông qua tài khoản đã đăng
ký bằng cách cung cấp email và mật khẩu. Khách hàng có thể thực hiện tất cả các
chức năng của khách vãng lai. Ngoài ra, khách hàng còn có thể thực hiện các chức
năng: đăng nhập, quản lý giỏ hàng, đặt hàng, thanh toán, đánh giá sản phẩm, quản lý
thông tin tài khoản, liên hệ, bình luận bài viết. Chức năng của quản lý giỏ hàng là cho
phép người dùng thêm sản phẩm vào giỏ hàng, sau khi thêm có thể cập nhật số lượng

sản phẩm và có thể xóa sản phẩm ra khỏi giỏ hàng; chức năng đặt hàng ,thanh toán
cho phép đặt hàng thông qua sản phẩm đã thêm vào giỏ hàng, để có thể hoàn tất chức
năng đặt hàng khách hàng phải chọn sản phẩm muốn đặt hàng từ giỏ hàng và sau đó
thì khách hàng phải chọn phương thức thanh toán trực tuyến qua ví điện tử hoặc chọn
phương thức thanh toán khi nhận hàng. Chức năng đánh giá sản phẩm cho phép khách
hàng đánh giá sản phẩm bằng cách xếp hạng từ 1 đến 5 sao, đồng thời kèm theo lời
bình luận về sản phẩm; chức năng quản lý thông tin cá nhân cho phép khách hàng
xem thông tin cá nhân, đồng thời cập nhật thông tin cá nhân như tên, email, số điện
thoại, địa chỉ, avatar, xem lịch sử mua hàng. Chức năng liên hệ cho phép khách hàng
có thể gửi yêu cầu về đến hệ thống, khi khách hàng muốn gửi liên hệ thì khách hàng
phải nhập đầy đủ các thông tin như: tên, email, số điện thoại, và thông tin yêu cầu;
sau khi điền đầy đủ thông tin và chọn gửi thì thông tin yêu cầu đó sẽ được gửi đến hệ
thống và người quản lý sẽ thấy thông tin liên hệ đó ở danh sách liên hệ, sau đó người
quản lý sẽ giải quyết yêu cầu liên hệ. Chức năng bình luận bài đăng cho phép khách
hàng có thể tương tác qua lại thông qua bình luận bài đăng.
Người quản lý đóng vai trò như chủ cửa hàng kinh doanh, người quản lý sử dụng
tài khoản được cấp để đăng nhập vào hệ thống. Người quản lý có thể thực hiện các
chức năng như khách hàng đồng thời người quản lý có thể thực hiện các chức năng
riêng của người quản lý như: thống kê, quản lý người dùng, quản lý sản phẩm, quản
lý đơn hàng, quản lý liên hệ, quản lý hình ảnh, quản lý bài đăng, quản lý đánh giá. Ở
giao diện quản lý có thanh menu giúp cho người quản lý có thể chuyển đổi qua lại
các chức năng với nhau.
Chức năng thống kê cho phép người quản lý xem tổng doanh thu của cửa hàng và
một số dữ liệu liên quan đến việc kinh doanh.
Chức năng quản lý người dùng cho phép xem danh sách người dùng, ngoài ra
người quản lý có thể sửa thông tin người dùng hoặc xóa tài khoản người dùng. Ngoài
ra, người quản lý có thể xuất danh sách người dùng ra file excel.
Chức năng quản lý sản phẩm cho phép xem danh sách sản phẩm trong hệ thống,
đồng thời người quản lý có thể thêm sản phẩm mới vào danh sách sản phẩm bằng
cách nhập thông tin sản phẩm bao gồm: tên sản phẩm, loại sản phẩm, giá sản phẩm,
hình ảnh, số lượng sản phẩm trong kho, mô tả sản phẩm, phần trăm giảm giá. Người
quản lý có thể sửa thông tin sản phẩm, xóa sản phẩm trong danh sách, tạo giảm giá
và nhấn vào nút tương ứng. Ngoài ra, người quản lý có thể xuất danh sách sản phẩm
ra file excel.
Chức năng quản lý đơn hàng cho phép xem danh sách các đơn hàng hiện có trong
hệ thống. Hiện có trong hệ thống 4 trạng thái: đã xác nhận, đã vận chuyển, đã nhận
hàng, đã thanh toán. Người quản lý có thể lọc đơn hàng theo từng trạng thái khác

nhau. Trạng thái xác nhận đơn hàng được người quản lý cập nhật. Trạng thái đã vận
chuyển được người quản lý cập nhật sao khi đã giao đơn hàng cho đơn vị vận chuyển.
Trạng thái đã nhận được hàng sẽ được quản lý cập nhật sau khi nhận thông báo giao
hàng thành công từ đơn vị vân chuyển. Người quản lý có thể in đơn hàng và xuất
danh sách đơn hàng ra file excel.
Chức năng quản lý liện hệ cho phép xem danh sách các liên hệ mà khách hàng
gửi tới. Hiện có trong hệ thống trạng thái đã xử lý. Người quản lý có thể lọc các liên
hệ đã xử lý hoặc các liên hệ chưa được xử lý. Trạng thái đã xử lý sẽ được người quản
lý cập nhật sau khi đã giải quyết yêu cầu của khách hàng. Ngoài ra, người quản lý có
thể xuất danh sách liên hệ ra file excel.
Chức năng quản lý hình ảnh cho phép xem danh sách hình ảnh đã thêm vào để tạo
sự đa dạng ở phần giao diện. Người quản lý có thể lọc hình ảnh theo loại. Ngoài ra,
người quản lý có thể thay đổi hoặc xóa hình ảnh ra khỏi danh sách.
Chức năng quản lý bài đăng cho phép xem danh sách bài đăng đã thêm vào để tạo
sự đa dạng ở phần giao diện. Người quản lý có thể lọc bài đăng theo loại. Ngoài ra,
người quản lý có thể thay đổi hoặc xóa bài đăng ra khỏi danh sách.
Chức năng quản lý đánh giá cho phép xem danh sách đánh giá. Người quản lý có
thể xóa các đánh giá xấu.






-------
1.2. Phân tích đánh giá giải pháp 
1.2.1. Giải pháp lựa chọn 
Trang web lựa chọn sử dụng React và dịch vụ cơ sở dữ liệu đám mây Firebase 
là một giải pháp tối ưu để xây dựng các ứng dụng web hiện đại với yêu cầu về thời 
gian phát triển nhanh, khả năng mở rộng cao cùng chi phí hợp lý. 
− React.js là một thư viện JavaScript phổ biến để xây dựng giao diện người 
dùng đơn trang (SPA - Single Page Application) - mượt mà và không cần 
tải lại toàn bộ trang khi có thay đổi. Với khả năng tái sử dụng component, 
React sở hữu tốc độ phát triển và hiệu suất cao. 
− Firebase là một nền tảng phát triển ứng dụng web toàn diện của Google. 
Firebase giúp đơn giản hóa việc triển khai và quản lý các ứng dụng web và 
di động bằng cách cung cấp các dịch vụ back-end như cơ sở dữ liệu, xác 
thực, lưu trữ tệp, thông báo, và hosting. 
1.2.2. Đánh giá giải pháp 
➢ Ưu điểm giải pháp; 
− Sự đơn giản trong phát triển: 
+ Cả hai công cụ Firebase và React đều sở hữu cộng đồng người dùng 
đông đảo cùng kho tài liệu và các thư viện hỗ trợ phong phú, đa dạng.
+ Firebase cung cấp các dịch vụ sẵn có như cơ sở dữ liệu, xác thực, lưu 
trữ và hosting. Từ đó giảm thiểu thời gian xây dựng và cấu hình. 
+ Việc sử dụng React (JavaScript/TypeScript) trên giao diện người dùng 
và Firebase SDK trên back-end giúp thống nhất ngôn ngữ phát triển, 
giảm độ phức tạp và tăng độ tích hợp của mã nguồn. 
+ Cấu trúc Firebase linh hoạt, cho phép mở rộng cơ sở dữ liệu và các chức 
năng một các dễ dàng. 
− Hiệu suất cao và trải nghiệm người dùng mượt mà: 
+ React sử dụng Virtual DOM để cập nhật giao diện nhanh chóng và mượt 
mà, cung cấp trải nghiệm tốt cho người dùng . 
+ Firebase và React kết hợp rất hiệu quả trong việc xử lý các tác vụ không 
đồng bộ, giúp ứng dụng hoạt động ổn định và nhanh chóng. 
+ Firebase Hosting cung cấp tốc độ tải trang nhanh, hỗ trợ HTTPS mặc 
định và tích hợp tốt với ứng dụng React. 
➢ Khuyết điểm giải pháp: 
Bên cạnh những ưu điểm mà công nghệ này mang lại, vẫn  có một số khuyết 
điểm tồn tại như sau: 
− Trong việc quản lý trạng thái của những dự án lớn, nhiều người dùng:  
+ Khi dự án trở nên phức tạp với nhiều thành phần, việc quản lý và đồng 
bộ dữ liệu có thể trở nên khó khăn, đòi hỏi kỹ thuật và kiến thức cao. 
+ Có thể gặp phải các giới hạn về tần suất đọc/ghi dữ liệu khi lượng yêu 
cầu tăng cao, gây ảnh hưởng đến hiệu suất xử lý.  
+ Do là NoSQL nên Firebase không tối ưu cho cơ sở dữ liệu truyền thống. 


font: Poppins










@theme {
  --font-family: 'Lexend', sans-serif;

  /* Font weights */
  --font-weight-thin: 100;
  --font-weight-extralight: 200;
  --font-weight-light: 300;
  --font-weight-regular: 400;
  --font-weight-medium: 500;
  --font-weight-semibold: 600;
  --font-weight-bold: 700;
  --font-weight-extrabold: 800;
  --font-weight-black: 900;

  /* Font sizes */
  --font-size-xs: 0.75rem;
  --font-size-sm: 0.875rem;
  --font-size-base: 1rem;
  --font-size-lg: 1.125rem;
  --font-size-xl: 1.25rem;
  --font-size-2xl: 1.5rem;
  --font-size-3xl: 1.875rem;
  --font-size-4xl: 2.25rem;
  --font-size-5xl: 3rem;

  /* Theme color – Light mode */
  --color-primary: oklch(0.65 0.15 160);      /* Xanh lá tươi */
  --color-accent: oklch(0.95 0.14 100);       /* Vàng chanh */
  --color-secondary: oklch(0.55 0.07 30);     /* Nâu nhạt - chữ chính */
  --color-background: oklch(0.98 0.01 0);     /* Trắng kem */
  --color-card: oklch(0.95 0.03 160);         /* Xanh lá nhạt */
  --color-text: oklch(0.55 0.07 30);          /* Nâu nhạt - chữ chính */
  --muted: oklch(0.967 0.001 286.375);
  --muted-foreground: oklch(0.552 0.016 285.938);
  --color-background-d: oklch(0.35 0.08 170);
  --color-background-l: oklch(0.98 0.01 0);     /* Trắng kem */


  --radius: 0.625rem;
  --radius-sm: 0.425rem;
  --color-border: oklch(0.922 0 0);
  --color-ring: oklch(0.708 0 0);

  /* Additional Chart color */
  --color-chart-1: oklch(0.646 0.222 41.116);
  --color-chart-2: oklch(0.6 0.118 184.704);
  --color-chart-3: oklch(0.398 0.07 227.392);
  --color-chart-4: oklch(0.828 0.189 84.429);
  --color-chart-5: oklch(0.769 0.188 70.08);

  
}

/* Base font styles */
:root {
  font-family: var(--font-family);
  line-height: 1.5;
  font-weight: var(--font-weight-regular);
  font-size: var(--font-size-base);
  box-sizing: border-box;
  padding: 0;
  margin: 0;
  /* overflow: auto !important; */
  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

.dark {
    --color-primary: oklch(0.75 0.12 160);     /* Xanh lá sáng */
    --color-accent: oklch(0.92 0.08 100);     
    --color-secondary: oklch(0.70 0.05 30);    
    --color-background: oklch(0.35 0.08 170);
    --color-card: oklch(0.45 0.10 160);
    --color-text: #e4dbdd;  
            /* Xám sáng */
}



//// search:
package com.ttoannguyen.lemongrass.search.service;

import co.elastic.clients.elasticsearch.ElasticsearchAsyncClient;
import co.elastic.clients.elasticsearch._types.FieldValue;
import co.elastic.clients.elasticsearch._types.query_dsl.Query;
import co.elastic.clients.elasticsearch._types.query_dsl.TextQueryType;
import co.elastic.clients.elasticsearch.core.search.Hit;
import com.ttoannguyen.lemongrass.exception.AppException;
import com.ttoannguyen.lemongrass.exception.enums.ErrorCode;
import com.ttoannguyen.lemongrass.search.document.RecipeDocument;
import com.ttoannguyen.lemongrass.search.dto.SearchRequest;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

@Slf4j
@Service
@RequiredArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
public class SearchService {
  ElasticsearchAsyncClient elasticsearchAsyncClient;

  public CompletableFuture<List<RecipeDocument>> search(SearchRequest request) {
    log.debug("Starting search with request: {}", request);

    if (request.getKeyword() == null || request.getKeyword().isEmpty()) {
      log.error("Search keyword is required");
      throw new AppException(ErrorCode.SEARCH_KEYWORD_REQUIRED);
    }

    // Build query
    List<Query> shouldQueries = new ArrayList<>();
    List<Query> filterQueries = new ArrayList<>();

    // Always filter out deleted recipes
    filterQueries.add(Query.of(q -> q.term(t -> t.field("isDeleted").value(false))));

    // If only keyword is provided, perform natural search; otherwise, include additional filters
    if (request.getCategoryIds() == null && request.getDifficulty() == null) {
      // Natural search: Query for title, ingredients, description
      shouldQueries.add(
          Query.of(
              q ->
                  q.multiMatch(
                      m ->
                          m.query(request.getKeyword())
                              .fields(List.of("title^2", "title.suggest^1.5", "title.trigram"))
                              .analyzer("vietnamese_analyzer")
                              .type(TextQueryType.BestFields))));

      shouldQueries.add(
          Query.of(
              q ->
                  q.nested(
                      n ->
                          n.path("ingredients")
                              .query(
                                  nq ->
                                      nq.multiMatch(
                                          m ->
                                              m.query(request.getKeyword())
                                                  .fields(
                                                      List.of(
                                                          "ingredients.name^1.5",
                                                          "ingredients.name.suggest"))
                                                  .analyzer("vietnamese_analyzer")
                                                  .type(TextQueryType.BestFields))))));

      shouldQueries.add(
          Query.of(
              q ->
                  q.multiMatch(
                      m ->
                          m.query(request.getKeyword())
                              .fields(List.of("description", "description.suggest"))
                              .analyzer("vietnamese_analyzer")
                              .type(TextQueryType.BestFields))));
    } else {
      // Regular search: Include query_string for non-nested fields
      shouldQueries.add(
          Query.of(
              q ->
                  q.queryString(
                      qs ->
                          qs.fields(List.of("title^2", "description", "accountName"))
                              .query(request.getKeyword())
                              .defaultOperator(
                                  co.elastic.clients.elasticsearch._types.query_dsl.Operator.And)
                              .fuzziness("AUTO"))));

      // Nested query for ingredients.name
      shouldQueries.add(
          Query.of(
              q ->
                  q.nested(
                      n ->
                          n.path("ingredients")
                              .query(
                                  nq ->
                                      nq.match(
                                          m ->
                                              m.field("ingredients.name")
                                                  .query(request.getKeyword())
                                                  .operator(
                                                      co.elastic.clients.elasticsearch._types.query_dsl
                                                          .Operator.And)
                                                  .fuzziness("AUTO"))))));

      // Nested query for instructions.description
      shouldQueries.add(
          Query.of(
              q ->
                  q.nested(
                      n ->
                          n.path("instructions")
                              .query(
                                  nq ->
                                      nq.match(
                                          m ->
                                              m.field("instructions.description")
                                                  .query(request.getKeyword())
                                                  .operator(
                                                      co.elastic.clients.elasticsearch._types.query_dsl
                                                          .Operator.And)
                                                  .fuzziness("AUTO"))))));
    }

    // Add filters for categoryIds and difficulty if provided
    if (request.getCategoryIds() != null && !request.getCategoryIds().isEmpty()) {
      filterQueries.add(
          Query.of(
              q ->
                  q.terms(
                      t ->
                          t.field("categoryIds")
                              .terms(
                                  ts ->
                                      ts.value(
                                          request.getCategoryIds().stream()
                                              .map(FieldValue::of)
                                              .collect(Collectors.toList()))))));
    }

    if (request.getDifficulty() != null && !request.getDifficulty().isEmpty()) {
      filterQueries.add(
          Query.of(q -> q.term(t -> t.field("difficulty").value(request.getDifficulty()))));
    }

    // Build final bool query
    Query finalQuery =
        Query.of(
            q ->
                q.bool(b -> b.should(shouldQueries).filter(filterQueries).minimumShouldMatch("1")));

    // Execute search
    return elasticsearchAsyncClient
        .search(
            s ->
                s.index("recipes")
                    .query(finalQuery)
                    .from(0)
                    .size(10)
                    .source(
                        src ->
                            src.filter(
                                f ->
                                    f.includes(
                                        List.of("title", "ingredients.name", "description"))))
                    .highlight(
                        h ->
                            h.fields("title", f -> f)
                                .fields("title.suggest", f -> f)
                                .fields("ingredients.name", f -> f)
                                .fields("ingredients.name.suggest", f -> f)
                                .fields("description", f -> f)
                                .fields("description.suggest", f -> f)),
            RecipeDocument.class)
        .thenApply(
            response -> {
              log.debug("Search completed, hits: {}", response.hits().hits().size());
              return response.hits().hits().stream()
                  .filter(hit -> hit.source() != null)
                  .map(
                      hit -> {
                        RecipeDocument doc = hit.source();
                        doc.setHighlight(hit.highlight()); // Lưu highlight
                        return doc;
                      })
                  .collect(Collectors.toList());
            })
        .exceptionally(
            throwable -> {
              log.error("Search failed: {}", throwable.getMessage(), throwable);
              throw new AppException(ErrorCode.SEARCH_FAILED);
            });
  }

  public CompletableFuture<List<RecipeDocument>> autocomplete(String keyword) {
    log.debug("Starting autocomplete with keyword: {}", keyword);
    if (keyword == null || keyword.isEmpty()) {
      log.error("Autocomplete keyword is required");
      throw new AppException(ErrorCode.SEARCH_KEYWORD_REQUIRED);
    }

    Query autocompleteQuery =
        Query.of(
            q ->
                q.multiMatch(
                    m ->
                        m.query(keyword)
                            .fields(List.of("title.suggest", "ingredients.name.suggest"))
                            .type(TextQueryType.BoolPrefix)
                            .analyzer("vietnamese_suggest_analyzer")));

    Query finalQuery =
        Query.of(
            q ->
                q.bool(
                    b ->
                        b.must(autocompleteQuery)
                            .filter(
                                Query.of(f -> f.term(t -> t.field("isDeleted").value(false))))));

    return elasticsearchAsyncClient
        .search(
            s ->
                s.index("recipes")
                    .query(finalQuery)
                    .size(5)
                    .source(
                        src -> src.filter(f -> f.includes(List.of("title", "ingredients.name"))))
                    .highlight(
                        h ->
                            h.fields("title.suggest", f -> f)
                                .fields("ingredients.name.suggest", f -> f)),
            RecipeDocument.class)
        .thenApply(
            response -> {
              log.debug("Autocomplete completed, hits: {}", response.hits().hits().size());
              return response.hits().hits().stream()
                  .filter(hit -> hit.source() != null)
                  .map(
                      hit -> {
                        RecipeDocument doc = hit.source();
                        doc.setHighlight(hit.highlight()); // Lưu highlight
                        return doc;
                      })
                  .collect(Collectors.toList());
            })
        .exceptionally(
            throwable -> {
              log.error("Autocomplete failed: {}", throwable.getMessage(), throwable);
              throw new AppException(ErrorCode.SEARCH_FAILED);
            });
  }
}










//// UPDATE RECIPE:
package com.ttoannguyen.lemongrass.service.impl;

import co.elastic.clients.elasticsearch.ElasticsearchAsyncClient;
import co.elastic.clients.elasticsearch.core.IndexResponse;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.ttoannguyen.lemongrass.dto.Request.image.ImageRequest;
import com.ttoannguyen.lemongrass.dto.Request.image.ImageUpdateRequest;
import com.ttoannguyen.lemongrass.dto.Request.ingredient.IngredientCreationRequest;
import com.ttoannguyen.lemongrass.dto.Request.ingredient.IngredientUpdateRequest;
import com.ttoannguyen.lemongrass.dto.Request.instruction.InstructionCreationRequest;
import com.ttoannguyen.lemongrass.dto.Request.instruction.InstructionUpdateRequest;
import com.ttoannguyen.lemongrass.dto.Request.recipe.RecipeCreationRequest;
import com.ttoannguyen.lemongrass.dto.Request.recipe.RecipeUpdateRequest;
import com.ttoannguyen.lemongrass.dto.Response.recipe.RecipeGetUpdateResponse;
import com.ttoannguyen.lemongrass.dto.Response.recipe.RecipeResponse;
import com.ttoannguyen.lemongrass.entity.*;
import com.ttoannguyen.lemongrass.exception.AppException;
import com.ttoannguyen.lemongrass.exception.enums.ErrorCode;
import com.ttoannguyen.lemongrass.mapper.RecipeMapper;
import com.ttoannguyen.lemongrass.repository.*;
import com.ttoannguyen.lemongrass.search.document.RecipeDocument;
import com.ttoannguyen.lemongrass.service.CloudinaryService;
import com.ttoannguyen.lemongrass.service.RecipeService;
import jakarta.transaction.Transactional;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

@Slf4j
@Service
@RequiredArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
public class RecipeServiceImpl implements RecipeService {

  ElasticsearchAsyncClient elasticsearchAsyncClient;
  RecipeMapper recipeMapper;
  ObjectMapper objectMapper = new ObjectMapper();
  ImageRepository imageRepository;
  RecipeRepository recipeRepository;
  CloudinaryService cloudinaryService;
  CategoryRepository categoryRepository;
  AccountRepository accountRepository;
  IngredientRepository ingredientRepository;
  InstructionRepository instructionRepository;
  IngredientUnitRepository ingredientUnitRepository;
  IngredientTemplateRepository ingredientTemplateRepository;

  @Override
  @Transactional
  public RecipeResponse create(RecipeCreationRequest request, String username) {
    Account account =
        accountRepository
            .findByUsername(username)
            .orElseThrow(() -> new AppException(ErrorCode.USER_NOT_EXISTED));

    Recipe recipe = buildBaseRecipe(request, account);
    recipeRepository.save(recipe);

    if (request.getCategoryIds() != null) {
      log.info("Resolving categories: {}", request.getCategoryIds());
      List<Category> categories = resolveCategories(request.getCategoryIds());
      log.info("Categories resolved: {}", categories);
      recipe.setCategories(new ArrayList<>(categories));
      log.info("Categories set on recipe, type: {}", recipe.getCategories().getClass().getName());
      categories.forEach(
          category -> {
            log.info("Updating category {} recipes", category.getId());
            if (category.getRecipes() == null) {
              log.info("Initializing recipes for category {}", category.getId());
              category.setRecipes(new ArrayList<>());
            }
            log.info(
                "Category recipes type before add: {}", category.getRecipes().getClass().getName());
            category.getRecipes().add(recipe);
          });
      log.info("Saving categories");
      categoryRepository.saveAll(categories);
      log.info("Categories saved");
    }

    if (request.getIngredients() != null) {
      log.info("Building ingredients: {}", request.getIngredients());
      List<Ingredient> ingredients = buildIngredients(request.getIngredients(), recipe);
      ingredientRepository.saveAll(ingredients);
      recipe.setIngredients(new ArrayList<>(ingredients));
      log.info("Ingredients set, type: {}", recipe.getIngredients().getClass().getName());
    }

    if (request.getInstructions() != null) {
      log.info("Building instructions: {}", request.getInstructions());
      List<Instruction> instructions = buildInstructions(request.getInstructions(), recipe);
      instructionRepository.saveAll(instructions);
      recipe.setInstructions(new ArrayList<>(instructions));
      log.info("Instructions set, type: {}", recipe.getInstructions().getClass().getName());
    }

    if (request.getImages() != null) {
      log.info("Uploading images: {}", request.getImages());
      List<Image> images = uploadImages(request.getImages(), recipe, null);
      imageRepository.saveAll(images);
      recipe.setImages(new ArrayList<>(images));
      log.info("Images set, type: {}", recipe.getImages().getClass().getName());
    }

    log.info("Converting recipe to document for Elasticsearch!");
    RecipeDocument document;
    try {
      document = mapToDocument(recipe, account);
      log.info("RecipeDocument created: {}", document.getId());
      String prettyJson =
          objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(document);
      System.out.println(prettyJson);

    } catch (Exception e) {
      log.error(
          "Failed to create RecipeDocument for recipe {}: {}", recipe.getId(), e.getMessage(), e);
      throw new AppException(ErrorCode.RECIPE_DOCUMENT_CREATION_FAILED);
    }

    log.info("Starting async indexing for recipe: {}", recipe.getId());
    CompletableFuture.runAsync(
        () -> {
          try {
            IndexResponse response =
                elasticsearchAsyncClient
                    .index(i -> i.index("recipes").id(recipe.getId()).document(document))
                    .get();
            log.info(
                "- Async indexed recipe {} in Elasticsearch with result: {}",
                recipe.getId(),
                response.result());
          } catch (Exception e) {
            log.error(
                "- Failed to async index recipe {} in Elasticsearch: {}",
                recipe.getId(),
                e.getMessage());
          }
        });

    return recipeMapper.toRecipeResponse(recipe);
  }

  @Override
  @Transactional
  public RecipeResponse update(RecipeUpdateRequest request, String username) {
    log.info("Starting recipe update for ID: {}, username: {}", request.getId(), username);

    log.info("Fetching account for username: {}", username);
    Account account =
        accountRepository
            .findByUsername(username)
            .orElseThrow(() -> new AppException(ErrorCode.USER_NOT_EXISTED));

    Recipe recipe =
        recipeRepository
            .findById(request.getId())
            .orElseThrow(() -> new AppException(ErrorCode.RECIPE_NOT_EXISTED));
    if (!recipe.getAccount().getId().equals(account.getId())) {
      log.error("User {} not authorized to update recipe {}", username, request.getId());
      throw new AppException(ErrorCode.UNAUTHORIZED);
    }
    recipe.setTitle(request.getTitle());
    recipe.setCookingTime(request.getCookingTime());
    recipe.setDifficulty(request.getDifficulty());
    recipe.setDescription(request.getDescription());
    recipe.setServings(request.getServings());
    recipeRepository.save(recipe);

    //    if (request.getTags() != null) {
    //      recipe.getTags().clear();
    //      Set<Tag> tags = resolveTags(request.getTags());
    //      recipe.setTags(new HashSet<>(tags));
    //      log.info("Tags updated, type: {}", recipe.getTags().getClass().getName());
    //    }

    if (request.getCategoryIds() != null) {
      recipe
          .getCategories()
          .forEach(
              category -> {
                log.info("Removing recipe {} from category {}", recipe.getId(), category.getId());
                if (category.getRecipes() != null) {
                  category.getRecipes().remove(recipe);
                }
              });
      categoryRepository.saveAll(recipe.getCategories());
      recipe.getCategories().clear();
      log.info("Resolving new categories: {}", request.getCategoryIds());
      List<Category> categories = resolveCategories(request.getCategoryIds());
      recipe.setCategories(new ArrayList<>(categories));
      categories.forEach(
          category -> {
            if (category.getRecipes() == null) {
              category.setRecipes(new ArrayList<>());
            }
            category.getRecipes().add(recipe);
          });
      categoryRepository.saveAll(categories);
    }

    if (request.getIngredients() != null) {
      Map<String, Ingredient> existingMap =
          recipe.getIngredients().stream().collect(Collectors.toMap(Ingredient::getId, ing -> ing));

      List<Ingredient> updatedList = new ArrayList<>();
      for (IngredientUpdateRequest reqIng : request.getIngredients()) {
        if (reqIng.getId() != null && existingMap.containsKey(reqIng.getId())) {
          // Update ingredient cũ
          Ingredient ing = existingMap.get(reqIng.getId());
          ing.setQuantity(reqIng.getQuantity());
          ing.setNote(reqIng.getNote());
          ing.setOrderIndex(reqIng.getOrderIndex());
          ing.setTemplate(
              ingredientTemplateRepository
                  .findById(reqIng.getTemplateId())
                  .orElseThrow(() -> new AppException(ErrorCode.INGREDIENT_TEMPLATE_NOT_EXISTED)));
          ing.setUnit(
              ingredientUnitRepository
                  .findById(reqIng.getUnitId())
                  .orElseThrow(() -> new AppException(ErrorCode.INGREDIENT_UNIT_NOT_EXISTED)));
          updatedList.add(ing);
        } else {
          // Thêm mới
          Ingredient newIng =
              Ingredient.builder()
                  .recipe(recipe)
                  .template(
                      ingredientTemplateRepository
                          .findById(reqIng.getTemplateId())
                          .orElseThrow(
                              () -> new AppException(ErrorCode.INGREDIENT_TEMPLATE_NOT_EXISTED)))
                  .unit(
                      ingredientUnitRepository
                          .findById(reqIng.getUnitId())
                          .orElseThrow(
                              () -> new AppException(ErrorCode.INGREDIENT_UNIT_NOT_EXISTED)))
                  .quantity(reqIng.getQuantity())
                  .note(reqIng.getNote())
                  .orderIndex(reqIng.getOrderIndex())
                  .build();
          updatedList.add(newIng);
        }
      }

      Set<String> requestIds =
          request.getIngredients().stream()
              .map(IngredientUpdateRequest::getId)
              .filter(Objects::nonNull)
              .collect(Collectors.toSet());

      List<Ingredient> toRemove =
          recipe.getIngredients().stream()
              .filter(ing -> !requestIds.contains(ing.getId()))
              .toList();
      ingredientRepository.deleteAll(toRemove);

      recipe.setIngredients(updatedList);
      ingredientRepository.saveAll(updatedList);

      //      ingredientRepository.deleteAll(recipe.getIngredients());
      //      recipe.getIngredients().clear();
      //      List<Ingredient> ingredients = buildIngredients(request.getIngredients(), recipe);
      //      ingredientRepository.saveAll(ingredients);
      //      recipe.setIngredients(new ArrayList<>(ingredients));
    }

    if (request.getInstructions() != null) {
      // 1. Lấy tất cả instruction hiện có trong DB thành Map để tra cứu nhanh theo ID
      Map<String, Instruction> existingMap =
          recipe.getInstructions().stream()
              .collect(Collectors.toMap(Instruction::getId, ins -> ins));

      // 2. Tạo danh sách mới để chứa instruction đã update hoặc thêm mới
      List<Instruction> updatedList = new ArrayList<>();

      // 3. Duyệt qua danh sách instruction từ request
      for (InstructionUpdateRequest reqIns : request.getInstructions()) {
        if (reqIns.getId() != null && existingMap.containsKey(reqIns.getId())) {
          // 4. Nếu có ID và tồn tại trong DB → Update dữ liệu cũ
          Instruction ins = existingMap.get(reqIns.getId());
          ins.setStepNumber(reqIns.getStepNumber());
          ins.setDescription(reqIns.getDescription());

          // 5. Xử lý ảnh trong instruction
          if (reqIns.getImages() != null) {
            Map<String, Image> existingImages =
                ins.getImages().stream().collect(Collectors.toMap(Image::getId, img -> img));

            List<Image> updatedImages = new ArrayList<>();

            for (ImageUpdateRequest imgReq : reqIns.getImages()) {
              if (imgReq.getId() != null && existingImages.containsKey(imgReq.getId())) {
                // 6. Update ảnh cũ
                Image img = existingImages.get(imgReq.getId());
                img.setDisplayOrder(imgReq.getDisplayOrder());
                updatedImages.add(img);
              } else {
                // 7. Thêm ảnh mới
                String url = cloudinaryService.uploadImage(imgReq.getFile());
                Image newImg =
                    Image.builder()
                        .url(url)
                        .displayOrder(imgReq.getDisplayOrder())
                        .instruction(ins)
                        .build();
                updatedImages.add(newImg);
              }
            }

            // 8. Xóa ảnh không còn trong request
            Set<String> reqImageIds =
                reqIns.getImages().stream()
                    .map(ImageUpdateRequest::getId)
                    .filter(Objects::nonNull)
                    .collect(Collectors.toSet());
            List<Image> toRemove =
                ins.getImages().stream().filter(img -> !reqImageIds.contains(img.getId())).toList();
            imageRepository.deleteAll(toRemove);

            ins.setImages(updatedImages);
          }

          updatedList.add(ins);

        } else {
          // 9. Nếu không có ID → Thêm instruction mới
          Instruction newIns =
              Instruction.builder()
                  .recipe(recipe)
                  .stepNumber(reqIns.getStepNumber())
                  .description(reqIns.getDescription())
                  .build();
          newIns = instructionRepository.save(newIns);

          // 10. Thêm ảnh cho instruction mới
          if (reqIns.getImages() != null) {
            Instruction finalNewIns = newIns;
            List<Image> newImages =
                reqIns.getImages().stream()
                    .map(
                        imgReq -> {
                          String url = cloudinaryService.uploadImage(imgReq.getFile());
                          return Image.builder()
                              .url(url)
                              .displayOrder(imgReq.getDisplayOrder())
                              .instruction(finalNewIns)
                              .build();
                        })
                    .toList();
            imageRepository.saveAll(newImages);
            newIns.setImages(new ArrayList<>(newImages));
          }

          updatedList.add(newIns);
        }
      }

      // 11. Xóa instruction nào không còn trong request
      Set<String> requestIds =
          request.getInstructions().stream()
              .map(InstructionUpdateRequest::getId)
              .filter(Objects::nonNull)
              .collect(Collectors.toSet());
      List<Instruction> toRemove =
          recipe.getInstructions().stream()
              .filter(ins -> !requestIds.contains(ins.getId()))
              .toList();
      instructionRepository.deleteAll(toRemove);

      // 12. Gán danh sách mới vào recipe và lưu
      recipe.setInstructions(updatedList);
      instructionRepository.saveAll(updatedList);
    }

    //    if (request.getInstructions() != null) {
    //      instructionRepository.deleteAll(recipe.getInstructions());
    //      recipe.getInstructions().clear();
    //      List<Instruction> instructions = buildInstructions(request.getInstructions(), recipe);
    //      instructionRepository.saveAll(instructions);
    //      recipe.setInstructions(new ArrayList<>(instructions));
    //    }

    //    if (request.getImages() != null) {
    //      imageRepository.deleteAll(recipe.getImages());
    //      recipe.getImages().clear();
    //      List<Image> images = uploadImages(request.getImages(), recipe, null);
    //      imageRepository.saveAll(images);
    //      recipe.setImages(new ArrayList<>(images));
    //    }

    if (request.getImages() != null) {
      // Map ảnh hiện có để tra nhanh
      Map<String, Image> existingImages =
          recipe.getImages().stream()
              .filter(img -> img.getId() != null)
              .collect(Collectors.toMap(Image::getId, img -> img));

      List<Image> updatedImages = new ArrayList<>();

      for (ImageUpdateRequest imgReq : request.getImages()) {
        if (imgReq.getId() != null && existingImages.containsKey(imgReq.getId())) {
          // Ảnh cũ → update displayOrder, giữ nguyên URL
          Image img = existingImages.get(imgReq.getId());
          img.setDisplayOrder(imgReq.getDisplayOrder());
          updatedImages.add(img);

        } else if (imgReq.getFile() != null) {
          // Ảnh mới có file → upload Cloudinary
          String url = cloudinaryService.uploadImage(imgReq.getFile());
          Image newImg =
              Image.builder()
                  .url(url)
                  .displayOrder(imgReq.getDisplayOrder())
                  .recipe(recipe)
                  .build();
          updatedImages.add(newImg);

        } else if (imgReq.getPreviewUrl() != null) {
          // Ảnh mới nhưng chỉ có previewUrl → giữ nguyên URL đó
          Image newImg =
              Image.builder()
                  .url(imgReq.getPreviewUrl())
                  .displayOrder(imgReq.getDisplayOrder())
                  .recipe(recipe)
                  .build();
          updatedImages.add(newImg);
        }
      }

      // Xóa ảnh không còn trong request
      Set<String> reqIds =
          request.getImages().stream()
              .map(ImageUpdateRequest::getId)
              .filter(Objects::nonNull)
              .collect(Collectors.toSet());

      List<Image> toRemove =
          recipe.getImages().stream()
              .filter(img -> img.getId() != null && !reqIds.contains(img.getId()))
              .toList();

      imageRepository.deleteAll(toRemove);

      // Lưu lại danh sách ảnh mới
      recipe.setImages(updatedImages);
      imageRepository.saveAll(updatedImages);
    }

    log.info("Converting recipe to document for Elasticsearch");
    RecipeDocument document;
    try {
      document = mapToDocument(recipe, account);
      log.info("RecipeDocument (update) created: {}", document.getId());
    } catch (Exception e) {
      log.error(
          "Failed to create RecipeDocument for recipe {}: {}", recipe.getId(), e.getMessage(), e);
      throw new AppException(ErrorCode.RECIPE_DOCUMENT_CREATION_FAILED);
    }

    log.info("- Starting async (update) indexing for recipe: {}", recipe.getId());
    CompletableFuture.runAsync(
        () -> {
          try {
            IndexResponse response =
                elasticsearchAsyncClient
                    .index(i -> i.index("recipes").id(recipe.getId()).document(document))
                    .get();
            log.info(
                "Async indexed recipe {} in Elasticsearch with result: {}",
                recipe.getId(),
                response.result());
          } catch (Exception e) {
            log.error(
                "Failed to async index recipe {} in Elasticsearch: {}",
                recipe.getId(),
                e.getMessage());
          }
        });

    log.info("Returning recipe updated response");
    return recipeMapper.toRecipeResponse(recipe);
  }

  @Override
  @Transactional
  public String delete(String recipeId, String username) {
    Account account =
        accountRepository
            .findByUsername(username)
            .orElseThrow(() -> new AppException(ErrorCode.USER_NOT_EXISTED));
    Recipe recipe =
        recipeRepository
            .findById(recipeId)
            .orElseThrow(() -> new AppException(ErrorCode.RECIPE_NOT_EXISTED));

    if (!recipe.getAccount().getId().equals(account.getId())) {
      log.error("User {} not authorized to delete recipe {}", username, recipeId);
      throw new AppException(ErrorCode.UNAUTHORIZED);
    }
    recipe.setIsDeleted(true);
    recipeRepository.save(recipe);

    RecipeDocument document;
    try {
      document = mapToDocument(recipe, account);
    } catch (Exception e) {
      log.error(
          "Failed to create RecipeDocument for recipe {}: {}", recipe.getId(), e.getMessage(), e);
      throw new AppException(ErrorCode.RECIPE_DOCUMENT_CREATION_FAILED);
    }

    CompletableFuture.runAsync(
        () -> {
          try {
            IndexResponse response =
                elasticsearchAsyncClient
                    .index(i -> i.index("recipes").id(recipe.getId()).document(document))
                    .get();
            log.info(
                "DELETE: Async indexed deleted recipe {} in Elasticsearch with result: {}",
                recipe.getTitle(),
                response.result());
          } catch (Exception e) {
            log.error(
                "Failed to async index deleted recipe {} in Elasticsearch: {}",
                recipeId,
                e.getMessage());
          }
        });
    return "Recipe deleted successfully!";
  }

  @Override
  public Page<RecipeResponse> getRecipes(
      Pageable pageable, String keyword, List<String> categoryIds, Integer maxTime) {

    if (keyword != null && keyword.trim().isEmpty()) {
      keyword = "";
    }

    if (categoryIds != null && categoryIds.isEmpty()) {
      categoryIds = null;
    }

    Page<Recipe> recipePage =
        recipeRepository.findAllWithFilters(pageable, keyword, categoryIds, maxTime);
    return recipePage.map(recipeMapper::toRecipeResponse);
  }

  @Override
  public RecipeResponse getRecipeId(String id) {
    return recipeRepository
        .findById(id)
        .map(recipeMapper::toRecipeResponse)
        .orElseThrow(() -> new AppException(ErrorCode.RECIPE_NOT_EXISTED));
  }

  @Override
  public RecipeGetUpdateResponse getUpdateRecipeId(String id) {
    return recipeRepository
        .findById(id)
        .map(recipeMapper::toRecipeGetUpdateResponse)
        .orElseThrow(() -> new AppException(ErrorCode.RECIPE_NOT_EXISTED));
  }

  @Override
  public RecipeResponse getRecipeName(String name) {
    return recipeRepository
        .findByTitle(name)
        .map(recipeMapper::toRecipeResponse)
        .orElseThrow(() -> new AppException(ErrorCode.RECIPE_NOT_EXISTED));
  }

  @Override
  public List<RecipeResponse> getMyRecipes(String username) {
    Account account =
        accountRepository
            .findByUsername(username)
            .orElseThrow(() -> new AppException(ErrorCode.USER_NOT_EXISTED));
    return recipeMapper.toRecipeResponseList(recipeRepository.findAllByAccountId(account.getId()));
  }

  @Override
  public List<RecipeResponse> getAccountRecipe(String id) {
    return recipeMapper.toRecipeResponseList(recipeRepository.findAllByAccountId(id));
  }

  private Recipe buildBaseRecipe(RecipeCreationRequest request, Account account) {
    return Recipe.builder()
        .title(request.getTitle())
        .cookingTime(request.getCookingTime())
        .difficulty(request.getDifficulty())
        .servings(request.getServings())
        .description(request.getDescription())
        .account(account)
        .isVerified(false)
        .isDeleted(false)
        .shareCount(0)
        .build();
  }

  private List<Category> resolveCategories(List<String> categoryIds) {
    log.info("- Resolving categories: {}", categoryIds);
    return categoryIds.stream()
        .map(
            categoryId -> {
              log.info("Fetching category by ID: {}", categoryId);
              return categoryRepository
                  .findById(categoryId)
                  .orElseThrow(() -> new AppException(ErrorCode.CATEGORY_NOT_EXISTED));
            })
        .collect(Collectors.toCollection(ArrayList::new));
  }

  //  private Set<Tag> resolveTags(List<TagCreationRequest> requests) {
  //    log.info("- Resolving tags: {}", requests);
  //    return requests.stream()
  //        .map(
  //            tagCreationRequest -> {
  //              log.info("Processing tag: {}", tagCreationRequest.getName());
  //              return tagRepository
  //                  .findByName(tagCreationRequest.getName())
  //                  .map(
  //                      existing -> {
  //                        if (!Objects.equals(existing.getColor(), tagCreationRequest.getColor()))
  // {
  //                          existing.setColor(tagCreationRequest.getColor());
  //                          log.info("Saving updated tag: {}", existing.getName());
  //                          tagRepository.save(existing);
  //                        }
  //                        return existing;
  //                      })
  //                  .orElseGet(
  //                      () -> {
  //                        Tag newTag =
  //                            Tag.builder()
  //                                .name(tagCreationRequest.getName())
  //                                .color(tagCreationRequest.getColor())
  //                                .build();
  //                        log.info("Saving new tag: {}", newTag.getName());
  //                        return tagRepository.save(newTag);
  //                      });
  //            })
  //        .collect(Collectors.toCollection(HashSet::new));
  //  }

  private List<Ingredient> buildIngredients(
      List<IngredientCreationRequest> requests, Recipe recipe) {
    log.info("Building ingredients for recipe: {}", recipe.getId());
    return requests.stream()
        .map(
            request -> {
              log.info("Fetching ingredient template: {}", request.getTemplateId());
              IngredientTemplate ingredientTemplate =
                  ingredientTemplateRepository
                      .findById(request.getTemplateId())
                      .orElseThrow(
                          () -> new AppException(ErrorCode.INGREDIENT_TEMPLATE_NOT_EXISTED));

              log.info("Fetching ingredient unit: {}", request.getUnitId());
              IngredientUnit ingredientUnit =
                  ingredientUnitRepository
                      .findById(request.getUnitId())
                      .orElseThrow(() -> new AppException(ErrorCode.INGREDIENT_UNIT_NOT_EXISTED));

              return Ingredient.builder()
                  .recipe(recipe)
                  .template(ingredientTemplate)
                  .unit(ingredientUnit)
                  .quantity(request.getQuantity())
                  .note(request.getNote())
                  .orderIndex(request.getOrderIndex())
                  .build();
            })
        .collect(Collectors.toCollection(ArrayList::new));
  }

  private List<Instruction> buildInstructions(
      List<InstructionCreationRequest> instructionCreationRequests, Recipe recipe) {
    log.info("Building instructions for recipe: {}", recipe.getId());
    List<Instruction> instructions = new ArrayList<>();

    for (InstructionCreationRequest req : instructionCreationRequests) {
      log.info("Building instruction step: {}", req.getStepNumber());
      Instruction instruction =
          Instruction.builder()
              .recipe(recipe)
              .stepNumber(req.getStepNumber())
              .description(req.getDescription())
              .build();
      instruction = instructionRepository.save(instruction);

      if (req.getImages() != null) {
        log.info("Uploading images for instruction step: {}", req.getStepNumber());
        List<Image> images = uploadImages(req.getImages(), null, instruction);
        imageRepository.saveAll(images);
        instruction.setImages(new ArrayList<>(images));
      }

      instructions.add(instruction);
    }

    return instructions;
  }

  private List<Image> uploadImages(
      List<ImageRequest> requests, Recipe recipe, Instruction instruction) {
    log.info(
        "Uploading images for recipe: {}, instruction: {}",
        recipe != null ? recipe.getId() : null,
        instruction != null ? instruction.getStepNumber() : null);
    return requests.stream()
        .map(
            img -> {
              log.info("Uploading image with display order: {}", img.getDisplayOrder());
              String url = cloudinaryService.uploadImage(img.getFile());
              return Image.builder()
                  .url(url)
                  .displayOrder(img.getDisplayOrder())
                  .recipe(recipe)
                  .instruction(instruction)
                  .build();
            })
        .collect(Collectors.toCollection(ArrayList::new));
  }

  private RecipeDocument mapToDocument(Recipe recipe, Account account) {
    return RecipeDocument.builder()
        .id(recipe.getId())
        .title(recipe.getTitle())
        .cookingTime(recipe.getCookingTime())
        .difficulty(recipe.getDifficulty() != null ? recipe.getDifficulty().name() : null)
        .description(recipe.getDescription())
        .servings(recipe.getServings())
        .accountId(account.getId())
        .accountName(account.getUsername())
        .categoryIds(
            recipe.getCategories() != null
                ? new ArrayList<>(recipe.getCategories().stream().map(Category::getName).toList())
                : new ArrayList<>())
        .ingredients(
            recipe.getIngredients() != null
                ? new ArrayList<>(
                    recipe.getIngredients().stream()
                        .map(
                            ing ->
                                new RecipeDocument.Ingredient(
                                    ing.getTemplate().getName(), ing.getQuantity().toString()))
                        .toList())
                : new ArrayList<>())
        .instructions(
            recipe.getInstructions() != null
                ? new ArrayList<>(
                    recipe.getInstructions().stream()
                        .map(
                            ins ->
                                new RecipeDocument.Instruction(
                                    ins.getStepNumber(), ins.getDescription()))
                        .toList())
                : new ArrayList<>())
        .images(
            recipe.getImages() != null
                ? new ArrayList<>(
                    recipe.getImages().stream()
                        .map(img -> new RecipeDocument.Image(img.getUrl()))
                        .toList())
                : new ArrayList<>())
        .isDeleted(recipe.getIsDeleted())
        .createdAt(recipe.getCreatedDate().toString())
        .updatedAt(recipe.getLastModifiedDate().toString())
        .build();
  }
}
